import {
  __commonJS
} from "./chunk-AUZ3RYOM.js";

// node_modules/midi-parser-js/src/main.js
var require_main = __commonJS({
  "node_modules/midi-parser-js/src/main.js"(exports, module) {
    (function() {
      "use strict";
      const _atob = function(string) {
        let b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        let b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
        string = string.replace(/^.*?base64,/, "");
        string = String(string).replace(/[\t\n\f\r ]+/g, "");
        if (!b64re.test(string))
          throw new TypeError("Failed to execute _atob() : The string to be decoded is not correctly encoded.");
        string += "==".slice(2 - (string.length & 3));
        let bitmap, result = "";
        let r1, r2, i = 0;
        for (; i < string.length; ) {
          bitmap = b64.indexOf(string.charAt(i++)) << 18 | b64.indexOf(string.charAt(i++)) << 12 | (r1 = b64.indexOf(string.charAt(i++))) << 6 | (r2 = b64.indexOf(string.charAt(i++)));
          result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
        }
        return result;
      };
      const MidiParser = {
        // debug (bool), when enabled will log in console unimplemented events
        // warnings and internal handled errors.
        debug: false,
        /**
         * [parse description]
         * @param  {[type]} input     [description]
         * @param  {[type]} _callback [description]
         * @return {[type]}           [description]
         */
        parse: function(input, _callback) {
          if (input instanceof Uint8Array)
            return MidiParser.Uint8(input);
          else if (typeof input === "string")
            return MidiParser.Base64(input);
          else if (input instanceof HTMLElement && input.type === "file")
            return MidiParser.addListener(input, _callback);
          else
            throw new Error("MidiParser.parse() : Invalid input provided");
        },
        /**
         * addListener() should be called in order attach a listener to the INPUT HTML element
         * that will provide the binary data automating the conversion, and returning
         * the structured data to the provided callback function.
         */
        addListener: function(_fileElement, _callback) {
          if (!File || !FileReader)
            throw new Error("The File|FileReader APIs are not supported in this browser. Use instead MidiParser.Base64() or MidiParser.Uint8()");
          if (_fileElement === void 0 || !(_fileElement instanceof HTMLElement) || _fileElement.tagName !== "INPUT" || _fileElement.type.toLowerCase() !== "file") {
            console.warn("MidiParser.addListener() : Provided element is not a valid FILE INPUT element");
            return false;
          }
          _callback = _callback || function() {
          };
          _fileElement.addEventListener("change", function(InputEvt) {
            if (!InputEvt.target.files.length)
              return false;
            console.log("MidiParser.addListener() : File detected in INPUT ELEMENT processing data..");
            let reader = new FileReader();
            reader.readAsArrayBuffer(InputEvt.target.files[0]);
            reader.onload = function(e) {
              _callback(MidiParser.Uint8(new Uint8Array(e.target.result)));
            };
          });
        },
        /**
         * Base64() : convert baset4 string into uint8 array buffer, before performing the
         * parsing subroutine.
         */
        Base64: function(b64String) {
          b64String = String(b64String);
          let raw = _atob(b64String);
          let rawLength = raw.length;
          let t_array = new Uint8Array(new ArrayBuffer(rawLength));
          for (let i = 0; i < rawLength; i++)
            t_array[i] = raw.charCodeAt(i);
          return MidiParser.Uint8(t_array);
        },
        /**
         * parse() : function reads the binary data, interpreting and spliting each chuck
         * and parsing it to a structured Object. When job is finised returns the object
         * or 'false' if any error was generated.
         */
        Uint8: function(FileAsUint8Array) {
          let file = {
            data: null,
            pointer: 0,
            movePointer: function(_bytes) {
              this.pointer += _bytes;
              return this.pointer;
            },
            readInt: function(_bytes) {
              _bytes = Math.min(_bytes, this.data.byteLength - this.pointer);
              if (_bytes < 1)
                return -1;
              let value = 0;
              if (_bytes > 1) {
                for (let i = 1; i <= _bytes - 1; i++) {
                  value += this.data.getUint8(this.pointer) * Math.pow(256, _bytes - i);
                  this.pointer++;
                }
              }
              value += this.data.getUint8(this.pointer);
              this.pointer++;
              return value;
            },
            readStr: function(_bytes) {
              let text = "";
              for (let char = 1; char <= _bytes; char++)
                text += String.fromCharCode(this.readInt(1));
              return text;
            },
            readIntVLV: function() {
              let value = 0;
              if (this.pointer >= this.data.byteLength) {
                return -1;
              } else if (this.data.getUint8(this.pointer) < 128) {
                value = this.readInt(1);
              } else {
                let FirstBytes = [];
                while (this.data.getUint8(this.pointer) >= 128) {
                  FirstBytes.push(this.readInt(1) - 128);
                }
                let lastByte = this.readInt(1);
                for (let dt = 1; dt <= FirstBytes.length; dt++) {
                  value += FirstBytes[FirstBytes.length - dt] * Math.pow(128, dt);
                }
                value += lastByte;
              }
              return value;
            }
          };
          file.data = new DataView(FileAsUint8Array.buffer, FileAsUint8Array.byteOffset, FileAsUint8Array.byteLength);
          if (file.readInt(4) !== 1297377380) {
            console.warn("Header validation failed (not MIDI standard or file corrupt.)");
            return false;
          }
          let headerSize = file.readInt(4);
          let MIDI = {};
          MIDI.formatType = file.readInt(2);
          MIDI.tracks = file.readInt(2);
          MIDI.track = [];
          let timeDivisionByte1 = file.readInt(1);
          let timeDivisionByte2 = file.readInt(1);
          if (timeDivisionByte1 >= 128) {
            MIDI.timeDivision = [];
            MIDI.timeDivision[0] = timeDivisionByte1 - 128;
            MIDI.timeDivision[1] = timeDivisionByte2;
          } else
            MIDI.timeDivision = timeDivisionByte1 * 256 + timeDivisionByte2;
          for (let t = 1; t <= MIDI.tracks; t++) {
            MIDI.track[t - 1] = { event: [] };
            let headerValidation = file.readInt(4);
            if (headerValidation === -1)
              break;
            if (headerValidation !== 1297379947)
              return false;
            file.readInt(4);
            let e = 0;
            let endOfTrack = false;
            let statusByte;
            let laststatusByte;
            while (!endOfTrack) {
              e++;
              MIDI.track[t - 1].event[e - 1] = {};
              MIDI.track[t - 1].event[e - 1].deltaTime = file.readIntVLV();
              statusByte = file.readInt(1);
              if (statusByte === -1)
                break;
              else if (statusByte >= 128)
                laststatusByte = statusByte;
              else {
                statusByte = laststatusByte;
                file.movePointer(-1);
              }
              if (statusByte === 255) {
                MIDI.track[t - 1].event[e - 1].type = 255;
                MIDI.track[t - 1].event[e - 1].metaType = file.readInt(1);
                let metaEventLength = file.readIntVLV();
                switch (MIDI.track[t - 1].event[e - 1].metaType) {
                  case 47:
                  case -1:
                    endOfTrack = true;
                    break;
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 7:
                  case 6:
                    MIDI.track[t - 1].event[e - 1].data = file.readStr(metaEventLength);
                    break;
                  case 33:
                  case 89:
                  case 81:
                    MIDI.track[t - 1].event[e - 1].data = file.readInt(metaEventLength);
                    break;
                  case 84:
                    MIDI.track[t - 1].event[e - 1].data = [];
                    MIDI.track[t - 1].event[e - 1].data[0] = file.readInt(1);
                    MIDI.track[t - 1].event[e - 1].data[1] = file.readInt(1);
                    MIDI.track[t - 1].event[e - 1].data[2] = file.readInt(1);
                    MIDI.track[t - 1].event[e - 1].data[3] = file.readInt(1);
                    MIDI.track[t - 1].event[e - 1].data[4] = file.readInt(1);
                    break;
                  case 88:
                    MIDI.track[t - 1].event[e - 1].data = [];
                    MIDI.track[t - 1].event[e - 1].data[0] = file.readInt(1);
                    MIDI.track[t - 1].event[e - 1].data[1] = file.readInt(1);
                    MIDI.track[t - 1].event[e - 1].data[2] = file.readInt(1);
                    MIDI.track[t - 1].event[e - 1].data[3] = file.readInt(1);
                    break;
                  default:
                    if (this.customInterpreter !== null) {
                      MIDI.track[t - 1].event[e - 1].data = this.customInterpreter(MIDI.track[t - 1].event[e - 1].metaType, file, metaEventLength);
                    }
                    if (this.customInterpreter === null || MIDI.track[t - 1].event[e - 1].data === false) {
                      file.readInt(metaEventLength);
                      MIDI.track[t - 1].event[e - 1].data = file.readInt(metaEventLength);
                      if (this.debug)
                        console.info("Unimplemented 0xFF meta event! data block readed as Integer");
                    }
                }
              } else {
                statusByte = statusByte.toString(16).split("");
                if (!statusByte[1])
                  statusByte.unshift("0");
                MIDI.track[t - 1].event[e - 1].type = parseInt(statusByte[0], 16);
                MIDI.track[t - 1].event[e - 1].channel = parseInt(statusByte[1], 16);
                switch (MIDI.track[t - 1].event[e - 1].type) {
                  case 15: {
                    if (this.customInterpreter !== null) {
                      MIDI.track[t - 1].event[e - 1].data = this.customInterpreter(MIDI.track[t - 1].event[e - 1].type, file, false);
                    }
                    if (this.customInterpreter === null || MIDI.track[t - 1].event[e - 1].data === false) {
                      let event_length = file.readIntVLV();
                      MIDI.track[t - 1].event[e - 1].data = file.readInt(event_length);
                      if (this.debug)
                        console.info("Unimplemented 0xF exclusive events! data block readed as Integer");
                    }
                    break;
                  }
                  case 10:
                  case 11:
                  case 14:
                  case 8:
                  case 9:
                    MIDI.track[t - 1].event[e - 1].data = [];
                    MIDI.track[t - 1].event[e - 1].data[0] = file.readInt(1);
                    MIDI.track[t - 1].event[e - 1].data[1] = file.readInt(1);
                    break;
                  case 12:
                  case 13:
                    MIDI.track[t - 1].event[e - 1].data = file.readInt(1);
                    break;
                  case -1:
                    endOfTrack = true;
                    break;
                  default:
                    if (this.customInterpreter !== null) {
                      MIDI.track[t - 1].event[e - 1].data = this.customInterpreter(MIDI.track[t - 1].event[e - 1].metaType, file, false);
                    }
                    if (this.customInterpreter === null || MIDI.track[t - 1].event[e - 1].data === false) {
                      console.log("Unknown EVENT detected... reading cancelled!");
                      return false;
                    }
                }
              }
            }
          }
          return MIDI;
        },
        /**
         * custom function to handle unimplemented, or custom midi messages.
         * If message is a meta-event, the value of metaEventLength will be >0.
         * Function must return the value to store, and pointer of dataView needs
         * to be manually increased
         * If you want default action to be performed, return false
         */
        customInterpreter: null
        // function( e_type , arrayByffer, metaEventLength){ return e_data_int }
      };
      if (typeof module !== "undefined")
        module.exports = MidiParser;
      else {
        let _global = typeof window === "object" && window.self === window && window || typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global;
        _global.MidiParser = MidiParser;
      }
    })();
  }
});
export default require_main();
//# sourceMappingURL=midi-parser-js.js.map
