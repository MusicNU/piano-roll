{
  "version": 3,
  "sources": ["../../midi-parser-js/src/main.js"],
  "sourcesContent": ["/*\n    Project Name : midi-parser-js\n    Project Url  : https://github.com/colxi/midi-parser-js/\n    Author       : colxi\n    Author URL   : http://www.colxi.info/\n    Description  : MidiParser library reads .MID binary files, Base64 encoded MIDI Data,\n    or UInt8 Arrays, and outputs as a readable and structured JS object.\n*/\n\n(function(){\n    'use strict';\n\n    /**\n     * CROSSBROWSER & NODEjs POLYFILL for ATOB() -\n     * By: https://github.com/MaxArt2501 (modified)\n     * @param  {string} string [description]\n     * @return {[type]}        [description]\n     */\n    const _atob = function(string) {\n        // base64 character set, plus padding character (=)\n        let b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        // Regular expression to check formal correctness of base64 encoded strings\n        let b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n        // remove data type signatures at the begining of the string\n        // eg :  \"data:audio/mid;base64,\"\n        string = string.replace( /^.*?base64,/ , '');\n        // atob can work with strings with whitespaces, even inside the encoded part,\n        // but only \\t, \\n, \\f, \\r and ' ', which can be stripped.\n        string = String(string).replace(/[\\t\\n\\f\\r ]+/g, '');\n        if (!b64re.test(string))\n            throw new TypeError('Failed to execute _atob() : The string to be decoded is not correctly encoded.');\n\n        // Adding the padding if missing, for semplicity\n        string += '=='.slice(2 - (string.length & 3));\n        let bitmap, result = '';\n        let r1, r2, i = 0;\n        for (; i < string.length;) {\n            bitmap = b64.indexOf(string.charAt(i++)) << 18 | b64.indexOf(string.charAt(i++)) << 12\n                    | (r1 = b64.indexOf(string.charAt(i++))) << 6 | (r2 = b64.indexOf(string.charAt(i++)));\n\n            result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255)\n                    : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255)\n                    : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);\n        }\n        return result;\n    };\n\n\n    /**\n     * [MidiParser description]\n     * @type {Object}\n     */\n    const MidiParser  = {\n        // debug (bool), when enabled will log in console unimplemented events\n        // warnings and internal handled errors.\n        debug: false,\n\n        /**\n         * [parse description]\n         * @param  {[type]} input     [description]\n         * @param  {[type]} _callback [description]\n         * @return {[type]}           [description]\n         */\n        parse: function(input, _callback){\n            if(input instanceof Uint8Array) return MidiParser.Uint8(input);\n            else if(typeof input === 'string') return MidiParser.Base64(input);\n            else if(input instanceof HTMLElement && input.type === 'file') return MidiParser.addListener(input , _callback);\n            else throw new Error('MidiParser.parse() : Invalid input provided');\n        },\n\n        /**\n         * addListener() should be called in order attach a listener to the INPUT HTML element\n         * that will provide the binary data automating the conversion, and returning\n         * the structured data to the provided callback function.\n         */\n        addListener: function(_fileElement, _callback){\n            if(!File || !FileReader) throw new Error('The File|FileReader APIs are not supported in this browser. Use instead MidiParser.Base64() or MidiParser.Uint8()');\n\n            // validate provided element\n            if( _fileElement === undefined ||\n                !(_fileElement instanceof HTMLElement) ||\n                _fileElement.tagName !== 'INPUT' ||\n                _fileElement.type.toLowerCase() !== 'file' \n            ){\n                console.warn('MidiParser.addListener() : Provided element is not a valid FILE INPUT element');\n                return false;\n            }\n            _callback = _callback || function(){};\n\n            _fileElement.addEventListener('change', function(InputEvt){             // set the 'file selected' event handler\n                if (!InputEvt.target.files.length) return false;                    // return false if no elements where selected\n                console.log('MidiParser.addListener() : File detected in INPUT ELEMENT processing data..');\n                let reader = new FileReader();                                      // prepare the file Reader\n                reader.readAsArrayBuffer(InputEvt.target.files[0]);                 // read the binary data\n                reader.onload =  function(e){\n                    _callback( MidiParser.Uint8(new Uint8Array(e.target.result)));  // encode data with Uint8Array and call the parser\n                };\n            });\n        },\n\n        /**\n         * Base64() : convert baset4 string into uint8 array buffer, before performing the\n         * parsing subroutine.\n         */\n        Base64 : function(b64String){\n            b64String = String(b64String);\n\n            let raw = _atob(b64String);\n            let rawLength = raw.length;\n            let t_array = new Uint8Array(new ArrayBuffer(rawLength));\n\n            for(let i=0; i<rawLength; i++) t_array[i] = raw.charCodeAt(i);\n            return  MidiParser.Uint8(t_array) ;\n        },\n\n        /**\n         * parse() : function reads the binary data, interpreting and spliting each chuck\n         * and parsing it to a structured Object. When job is finised returns the object\n         * or 'false' if any error was generated.\n         */\n        Uint8: function(FileAsUint8Array){\n            let file = {\n                data: null,\n                pointer: 0,\n                movePointer: function(_bytes){                                      // move the pointer negative and positive direction\n                    this.pointer += _bytes;\n                    return this.pointer;\n                },\n                readInt: function(_bytes){                                          // get integer from next _bytes group (big-endian)\n                    _bytes = Math.min(_bytes, this.data.byteLength-this.pointer);\n                    if (_bytes < 1) return -1;                                                                      // EOF\n                    let value = 0;\n                    if(_bytes > 1){\n                        for(let i=1; i<= (_bytes-1); i++){\n                            value += this.data.getUint8(this.pointer) * Math.pow(256, (_bytes - i));\n                            this.pointer++;\n                        }\n                    }\n                    value += this.data.getUint8(this.pointer);\n                    this.pointer++;\n                    return value;\n                },\n                readStr: function(_bytes){                                          // read as ASCII chars, the followoing _bytes\n                    let text = '';\n                    for(let char=1; char <= _bytes; char++) text +=  String.fromCharCode(this.readInt(1));\n                    return text;\n                },\n                readIntVLV: function(){                                             // read a variable length value\n                    let value = 0;\n                    if ( this.pointer >= this.data.byteLength ){\n                        return -1;                                                  // EOF\n                    }else if(this.data.getUint8(this.pointer) < 128){               // ...value in a single byte\n                        value = this.readInt(1);\n                    }else{                                                          // ...value in multiple bytes\n                        let FirstBytes = [];\n                        while(this.data.getUint8(this.pointer) >= 128){\n                            FirstBytes.push(this.readInt(1) - 128);\n                        }\n                        let lastByte  = this.readInt(1);\n                        for(let dt = 1; dt <= FirstBytes.length; dt++){\n                            value += FirstBytes[FirstBytes.length - dt] * Math.pow(128, dt);\n                        }\n                        value += lastByte;\n                    }\n                    return value;\n                }\n            };\n\n            file.data = new DataView(FileAsUint8Array.buffer, FileAsUint8Array.byteOffset, FileAsUint8Array.byteLength);                                            // 8 bits bytes file data array\n            //  ** read FILE HEADER\n            if(file.readInt(4) !== 0x4D546864){\n                console.warn('Header validation failed (not MIDI standard or file corrupt.)');\n                return false;                                                       // Header validation failed (not MIDI standard or file corrupt.)\n            }\n            let headerSize          = file.readInt(4);                              // header size (unused var), getted just for read pointer movement\n            let MIDI                = {};                                           // create new midi object\n            MIDI.formatType         = file.readInt(2);                              // get MIDI Format Type\n            MIDI.tracks             = file.readInt(2);                              // get ammount of track chunks\n            MIDI.track              = [];                                           // create array key for track data storing\n            let timeDivisionByte1   = file.readInt(1);                              // get Time Division first byte\n            let timeDivisionByte2   = file.readInt(1);                              // get Time Division second byte\n            if(timeDivisionByte1 >= 128){                                           // discover Time Division mode (fps or tpf)\n                MIDI.timeDivision    = [];\n                MIDI.timeDivision[0] = timeDivisionByte1 - 128;                     // frames per second MODE  (1st byte)\n                MIDI.timeDivision[1] = timeDivisionByte2;                           // ticks in each frame     (2nd byte)\n            }else MIDI.timeDivision  = (timeDivisionByte1 * 256) + timeDivisionByte2;// else... ticks per beat MODE  (2 bytes value)\n\n            //  ** read TRACK CHUNK\n            for(let t=1; t <= MIDI.tracks; t++){\n                MIDI.track[t-1]     = {event: []};                                  // create new Track entry in Array\n                let headerValidation = file.readInt(4);\n                if ( headerValidation === -1 ) break;                               // EOF\n                if(headerValidation !== 0x4D54726B) return false;                   // Track chunk header validation failed.\n                file.readInt(4);                                                    // move pointer. get chunk size (bytes length)\n                let e               = 0;                                            // init event counter\n                let endOfTrack      = false;                                        // FLAG for track reading secuence breaking\n                // ** read EVENT CHUNK\n                let statusByte;\n                let laststatusByte;\n                while(!endOfTrack){\n                    e++;                                                            // increase by 1 event counter\n                    MIDI.track[t-1].event[e-1] = {};                                // create new event object, in events array\n                    MIDI.track[t-1].event[e-1].deltaTime  = file.readIntVLV();      // get DELTA TIME OF MIDI event (Variable Length Value)\n                    statusByte = file.readInt(1);                                   // read EVENT TYPE (STATUS BYTE)\n                    if(statusByte === -1) break;                                    // EOF\n                    else if(statusByte >= 128) laststatusByte = statusByte;         // NEW STATUS BYTE DETECTED\n                    else{                                                           // 'RUNNING STATUS' situation detected\n                        statusByte = laststatusByte;                                // apply last loop, Status Byte\n                        file.movePointer(-1);                                       // move back the pointer (cause readed byte is not status byte)\n                    }\n\n\n                    //\n                    // ** IS META EVENT\n                    //\n                    if(statusByte === 0xFF){                                        // Meta Event type\n                        MIDI.track[t-1].event[e-1].type = 0xFF;                     // assign metaEvent code to array\n                        MIDI.track[t-1].event[e-1].metaType =  file.readInt(1);     // assign metaEvent subtype\n                        let metaEventLength = file.readIntVLV();                    // get the metaEvent length\n                        switch(MIDI.track[t-1].event[e-1].metaType){\n                            case 0x2F:                                              // end of track, has no data byte\n                            case -1:                                                // EOF\n                                endOfTrack = true;                                  // change FLAG to force track reading loop breaking\n                                break;\n                            case 0x01:                                              // Text Event\n                            case 0x02:                                              // Copyright Notice\n                            case 0x03:\n                            case 0x04:                                              // Instrument Name\n                            case 0x05:                                              // Lyrics)\n                            case 0x07:                                              // Cue point                                         // Sequence/Track Name (documentation: http://www.ta7.de/txt/musik/musi0006.htm)\n                            case 0x06:                                              // Marker\n                                MIDI.track[t-1].event[e-1].data = file.readStr(metaEventLength);\n                                break;\n                            case 0x21:                                              // MIDI PORT\n                            case 0x59:                                              // Key Signature\n                            case 0x51:                                              // Set Tempo\n                                MIDI.track[t-1].event[e-1].data = file.readInt(metaEventLength);\n                                break;\n                            case 0x54:                                              // SMPTE Offset\n                                MIDI.track[t-1].event[e-1].data    = [];\n                                MIDI.track[t-1].event[e-1].data[0] = file.readInt(1);\n                                MIDI.track[t-1].event[e-1].data[1] = file.readInt(1);\n                                MIDI.track[t-1].event[e-1].data[2] = file.readInt(1);\n                                MIDI.track[t-1].event[e-1].data[3] = file.readInt(1);\n                                MIDI.track[t-1].event[e-1].data[4] = file.readInt(1);\n                                break;\n                            case 0x58:                                              // Time Signature\n                                MIDI.track[t-1].event[e-1].data    = [];\n                                MIDI.track[t-1].event[e-1].data[0] = file.readInt(1);\n                                MIDI.track[t-1].event[e-1].data[1] = file.readInt(1);\n                                MIDI.track[t-1].event[e-1].data[2] = file.readInt(1);\n                                MIDI.track[t-1].event[e-1].data[3] = file.readInt(1);\n                                break;\n                            default :\n                                // if user provided a custom interpreter, call it\n                                // and assign to event the returned data\n                                if( this.customInterpreter !== null){\n                                    MIDI.track[t-1].event[e-1].data = this.customInterpreter( MIDI.track[t-1].event[e-1].metaType, file, metaEventLength);\n                                }\n                                // if no customInterpretr is provided, or returned\n                                // false (=apply default), perform default action\n                                if(this.customInterpreter === null || MIDI.track[t-1].event[e-1].data === false){\n                                    file.readInt(metaEventLength);\n                                    MIDI.track[t-1].event[e-1].data = file.readInt(metaEventLength);\n                                    if (this.debug) console.info('Unimplemented 0xFF meta event! data block readed as Integer');\n                                }\n                        }\n                    }\n\n                    //\n                    // IS REGULAR EVENT\n                    //\n                    else{                                                           // MIDI Control Events OR System Exclusive Events\n                        statusByte = statusByte.toString(16).split('');             // split the status byte HEX representation, to obtain 4 bits values\n                        if(!statusByte[1]) statusByte.unshift('0');                 // force 2 digits\n                        MIDI.track[t-1].event[e-1].type = parseInt(statusByte[0], 16);// first byte is EVENT TYPE ID\n                        MIDI.track[t-1].event[e-1].channel = parseInt(statusByte[1], 16);// second byte is channel\n                        switch(MIDI.track[t-1].event[e-1].type){\n                            case 0xF:{                                              // System Exclusive Events\n\n                                // if user provided a custom interpreter, call it\n                                // and assign to event the returned data\n                                if( this.customInterpreter !== null){\n                                    MIDI.track[t-1].event[e-1].data = this.customInterpreter( MIDI.track[t-1].event[e-1].type, file , false);\n                                }\n\n                                // if no customInterpretr is provided, or returned\n                                // false (=apply default), perform default action\n                                if(this.customInterpreter === null || MIDI.track[t-1].event[e-1].data === false){\n                                    let event_length = file.readIntVLV();\n                                    MIDI.track[t-1].event[e-1].data = file.readInt(event_length);\n                                    if (this.debug) console.info('Unimplemented 0xF exclusive events! data block readed as Integer');\n                                }\n                                break;\n                            }\n                            case 0xA:                                               // Note Aftertouch\n                            case 0xB:                                               // Controller\n                            case 0xE:                                               // Pitch Bend Event\n                            case 0x8:                                               // Note off\n                            case 0x9:                                               // Note On\n                                MIDI.track[t-1].event[e-1].data = [];\n                                MIDI.track[t-1].event[e-1].data[0] = file.readInt(1);\n                                MIDI.track[t-1].event[e-1].data[1] = file.readInt(1);\n                                break;\n                            case 0xC:                                               // Program Change\n                            case 0xD:                                               // Channel Aftertouch\n                                MIDI.track[t-1].event[e-1].data = file.readInt(1);\n                                break;\n                            case -1:                                                // EOF\n                                endOfTrack = true;                                  // change FLAG to force track reading loop breaking\n                                break;\n                            default:\n                                // if user provided a custom interpreter, call it\n                                // and assign to event the returned data\n                                if( this.customInterpreter !== null){\n                                    MIDI.track[t-1].event[e-1].data = this.customInterpreter( MIDI.track[t-1].event[e-1].metaType, file , false);\n                                }\n\n                                // if no customInterpretr is provided, or returned\n                                // false (=apply default), perform default action\n                                if(this.customInterpreter === null || MIDI.track[t-1].event[e-1].data === false){\n                                    console.log('Unknown EVENT detected... reading cancelled!');\n                                    return false;\n                                }\n                        }\n                    }\n                }\n            }\n            return MIDI;\n        },\n\n        /**\n         * custom function to handle unimplemented, or custom midi messages.\n         * If message is a meta-event, the value of metaEventLength will be >0.\n         * Function must return the value to store, and pointer of dataView needs\n         * to be manually increased\n         * If you want default action to be performed, return false\n         */\n        customInterpreter : null // function( e_type , arrayByffer, metaEventLength){ return e_data_int }\n    };\n\n\n    // if running in NODE export module\n    if(typeof module !== 'undefined') module.exports = MidiParser;\n    else{\n        // if running in Browser, set a global variable.\n        let _global = typeof window === 'object' && window.self === window && window ||\n                    typeof self === 'object' && self.self === self && self ||\n                    typeof global === 'object' && global.global === global && global;\n\n        _global.MidiParser = MidiParser;\n    }\n\n\n    \n})();"],
  "mappings": "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",
  "names": []
}
